---
title: "Creating Darwin Core with R"
author: 
- Lien Reyserhove
- Stijn Van Hoey
- Damiano Oldoni
- Peter Desmet
---

# Creating Darwin Core with R

This tutorial describes how to map checklist data to Darwin Core in a **stepwise manner**. It is good practice to use this approach each time you map your data.

1. General setup of the Rmd file
* Define locale
* Load libraries
2. Import and clean data
* Import data
* Inspect data
* Clean data
* Further processing
3. Mapping to Darwin Core Archive
* Pre-processing
* Mapping
	+ General concept
	+ Static Darwin Core fields
	+ Unaltered Darwin Core fields
	+ Altered Darwin Core fields
* Post-processing

We'll walk through the tutorial step-by-step by using the [Inventory of alien macroinvertebrates in Flanders, Belgium](https://www.gbif.org/dataset/289244ee-e1c1-49aa-b2d7-d379391ce265) as an example. Afterwards, you can try it yourself by mapping the [Checklist of non-native freshwater fishes in Flanders, Belgium](https://www.gbif.org/dataset/98940a79-2bf1-46e6-afd6-ba2e85a26f9f)

# General setup R

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Before we load the data, we define the *locale*:

```{r, eval = F}
Sys.setlocale("LC_CTYPE", "en_US.UTF-8")
```

We load the libraries necessary to *import*, *clean* and *map* the data:

```{r}
library(tidyverse) # For data mapping
library(magrittr)  # For %<>% pipes
library(readxl)    # To read excel files
library(janitor)   # Basic cleaning of the data
```

# Import and clean data

## Import data

Our raw datasat is an Excel file (AI_2016_Boets_etal_Supplement.xls). The import specifications for Excel files are more limited than those for other extensions such as `.tsv` or `.txt`. However, we think it's useful to use Excel as a format in this exercise as this is often used to manage datasets. 

* Select *Import dataset* in the *Environment* window --> *From Excel...*
* File/URL: *Browse* --> select `AI_2016_Boets_etal_Supplement.xls`
* Specify the *Import Options*:
    + Name = raw_data
    + Sheet = checklist
    + Specify empty values ("NA" or " ") 
    + Check on *First Row as Names*
* *Data preview*: data OK? --> *Import* to generate the dataframe.

```{r, echo = F}
raw_data <- read_excel("../data/raw/AI_2016_Boets_etal_Supplement.xls", 
     sheet = "checklist")
```

## Inspect data:

The simplest way for a quick overview of the raw data is by using the tools **head()** and **str()**: 

```{r}
head(raw_data)  # Displays the first 6 lines of the dataframe
```

```{r}
str(raw_data) 
```

## Clean data

We assume here that your dataset is tidy. If this is not the case, we refer to the previous session on *tidyverse* for a full overview of data cleaning skills. Unfortunately, starting with untidy data will make your script a lot more complex, with many preparatory steps before you can even start mapping! In a tidy dataset, you can start the mapping immediately.

In some cases, some small cleaning steps could be made to clean `raw_data`. 
Here, the column names of `raw_data` contain capital letters:

```{r, echo=FALSE}
colnames(raw_data)
```

It's easier to use lower case letters only and to discard all spaces in the column names. The package *janitor* provides some useful tools for this.

```{r}
raw_data %<>%  clean_names()    
```

```{r, echo=FALSE}
colnames(raw_data)
```

# Mapping to Darwin Core Archive

The mapping of checklist data to Darwin Core is a **stepwise process**:

1. **Pre-processing step**: Basic preparations before the mapping
2. **Mapping**: sequential addition of the Darwin Core fields
* Add static fields
* Add unaltered fields
* Add altered fields
3. **Post-processing step**: 

![Schematic overview of the mapping process](../docs/static/images/scheme_mapping_process.png)

We always map the **taxon core** first, as this is the central file and contains the checklist metadata, followed by the extensions. The example discussed here, we focus on the mapping of the taxon core. 


## Pre-processing:

1. We use a **copy of** `raw_data` as the starting point for the mapping of the taxon core. This is because `raw_data` is the **starting point** for the mapping of both the taxon core and the extensions. It needs to be untouched each time we start the mapping process. 

2. During the mapping, we will sequentially add new Darwin Core terms to `taxon`(see further). To make a clear distinction between the columns from `raw_data` and those from `taxon`, we add the prefix `raw_` to the column names of `raw_data` (as in some cases, some of the column names in `raw_data` will contain Darwin Core terms, such as `phylum` or `order`, which is confusing)
We do this **BEFORE** we generate `taxon`

```{r}
# Add prefix `raw_` to the column names of `raw_data`.
colnames(raw_data) <- paste0("raw_", colnames(raw_data))
```

```{r, echo = F}
head(raw_data)
```

```{r}
# Generate `taxon` by making a copy of `raw_data`: 
taxon <- raw_data
```

3. After the mapping, we need to **discard the original columns from the raw data file** from `taxon` in order to retain the mapped Darwin Core terms only. The most elegant way to do this is by saving the column names of `raw_data` in a vector (`raw_colnames`), and by using this vector to remove `raw_colnames` from `taxon` (using `select()`) after the mapping. 

```{r}
# Save the column names as a vector (enables to select all raw_column names efficiently after the mapping)
raw_colnames <- colnames(raw_data)
```

```{r, echo = F}
raw_colnames
```


## Mapping process:

### General concept:

The mapping process is **sequential**: we add the Darwin Core terms to `taxon` step by step. The Darwin Core terms for each file (core or extension) can be found on the [GBIF Resources page](http://rs.gbif.org/):

![](../docs/static/images/darwin_core_taxon.png)

It is good practice to inspect the Darwin Core terms on this webpage **one by one** to see whether a particular term can be used in your checklist. We respect the order of the terms as they listed on the GBIF resource page.

For each term we add to `taxon`, we use `mutate` and %<>% pipes` as basic tools.

To illustrate:

```{r, eval = F}
# Add nomenclaturalCode:
taxon %<>% mutate(nomenclaturalCode = "ICZN")

# Add taxonID:
taxon %<>% mutate(taxonID = raw_taxonID)

```

We distinguish three types of Darwin Core fields:

1. Static Darwin Core fields
2. Unaltered Darwin Core fields
3. Altered Darwin Core fields

### Static Darwin Core fields

Static Darwin Core fields contain values that remain fixed, i.e. they are independent from the record (row) in the dataset. Most often, they are absent in `raw_data`. This mostly concerns **metadata fields** in the Taxon Core file. 

#### language:

```{r}
taxon %<>% mutate(language = "en")
```

#### license:

```{r}
taxon %<>% mutate(license = "http://creativecommons.org/publicdomain/zero/1.0/")
```

#### rightsHolder:

```{r}
taxon %<>% mutate(rightsHolder = "Ghent University Aquatic Ecology")
```

#### datasetID

```{r}
taxon  %<>% mutate(datasetID = "https://doi.org/10.15468/yxcq07")
```
 
#### datasetName

```{r}
taxon %<>% mutate(datasetName = "Inventory of alien macroinvertebrates in Flanders, Belgium")
```

Other, non-metadata fields:

#### kingdom

```{r}
taxon %<>% mutate(kingdom = "Animalia")
```

View newly mapped fields in `taxon`:

```{r}
head(taxon)
```

### Unaltered fields: 

Unaltered fields are Darwin Core fields for which the content is an exact copy of the corresponding field in `raw_data`. This contrasts with **altered fields**, in which use a certain field in `raw_data` as a **basis** for further processing. 

Before deciding whether or not some basic processing is required, it is useful to screen the variables in `raw_data` for their specific content. A good method is to use the tool `distinct()` from `dplyr`, which returns the unique content of the variable:

```{r}
taxon %>% distinct(raw_phylum)
```

(Remark: we use `%>%` instead of `%<>%`, as we don't want to add a new column to `taxon`)

Some unaltered fields:

#### taxonID

```{r}
taxon %<>% mutate(taxonID = raw_taxon_id)
```

#### scientificName

```{r}
taxon %<>% mutate(scientificName = raw_species)
```

#### family

```{r}
taxon %<>% mutate(family = raw_family)

```

View newly mapped fields in `taxon`:

```{r}
head(taxon)
```

### Altered fields

These Darwin Core fields use the raw data as a basis, but the content of the raw data has been remapped. This applies to Darwin Core terms for which we use a [vocabulary](http://rs.gbif.org/vocabulary/gbif/). In other cases, we want to transform our data or correct some obvious mistakes. 

We use `mutate()` + `recode()` or  `mutate()` + `case_when()` as basic tools.

1. `mutate()` + `recode()`

In this case, we aim to replace specific information in `raw_data` by new information specified in the code.
For instance, `raw_order` will be mapped to the Darwin Core term `order`:

```{r}
taxon %>% distinct(raw_order)
```

`Veneroida` is a typo. We need to replace this by `Venerida`:

```{r}
taxon %<>% 
  mutate(order = recode(raw_order, "Veneroidea" = "Venerida")) 
```

We use `select()`, `group_by_all()` and `summarize()`to compare our newly mapped data with the original data:

```{r}
taxon %>% select(raw_order, order) %>%
  group_by_all() %>% 
  summarize()
```

Another use case:

`raw_phylum` will be mapped to to Darwin Core term `phylum`. 

```{r}
taxon %>% distinct(raw_phylum)
```

However, Crustacea is not a phylum but a subphylum. The phylum to which crustaceans belong is "Arthropoda". We use `recode()`:

```{r}
taxon %<>% mutate (phylum = recode (raw_phylum, "Crustacea" = "Arthropoda"))
```

Other use cases (not applicable to our data):

``` {r, eval = F}
distribution %<>% mutate(description = recode(raw_d_n,
  "Ext.?"     = "Ext.",
  "Ext./Cas." = "Cas.",
  "Cas.?"     = "Cas.",
  "Nat.?"     = "Nat.",
  .missing = ""))

distribution %<>% mutate(locality = recode(value,
  "AF"     = "Africa (WGSRPD:2)",
  "AM"     = "pan-American",
  "AS"     = "Asia",
  "AS-Te"  = "temperate Asia (WGSRPD:3)",
  "AS-Tr"  = "tropical Asia (WGSRPD:4)",
  "AUS"    = "Australasia (WGSRPD:5)",
  "Cult."  = "cultivated origin",
  "E"      = "Europe (WGSRPD:1)",
  "Hybr."  = "hybrid origin",
  "NAM"    = "Northern America (WGSRPD:7)",
  "SAM"    = "Southern America (WGSRPD:8)",
  "Trop."  = "Pantropical",
  .default = "",
  .missing = "" # As result of stripping, records with no native range already removed by gather()
))
```


2. `mutate()` + `case_when()`

`case_when` is often used together with `mutate()` when you want to make a new column (or change an existing one) based on the content of other existing variables.

For instance, [taxonRank](http://rs.gbif.org/vocabulary/gbif/rank_2015-04-24.xml) information is lacking in `raw_data`. We need to generate this information based on the information contained in `raw_species`:

Inspect `raw_species`:

```{r}
taxon %>% distinct(raw_species)
```

Although most `raw_species` are in fact species, `Dreissena rostriformis bugensis` is not a species but a subspecies. We need to make this distinction in the mapping process:

```{r}
taxon %<>% mutate(taxonRank = case_when(
  raw_species == "Dreissena rostriformis bugensis" ~ "subspecies",
  raw_species != "Dreissena rostriformis bugensis" ~ "species")
)
```

We use `select()`, `group_by_all()` and `summarize()`to compare our newly mapped data with the original data:

```{r}
taxon %>% select(raw_species, taxonRank) %>%
  group_by_all() %>% 
  summarize()
```

Other use cases (not applicable to our data):

```{r, eval=FALSE}
invasion_stage %<>% mutate(description = case_when(
  raw_status == "A" ~ "casual",
  raw_status == "A*" ~ "casual",
  raw_status == "N" ~ "established"
))


distribution %<>% 
  mutate(Flanders = case_when(
    raw_presence_fl == "X" & (is.na(raw_presence_br) | raw_presence_br == "?") & (is.na(raw_presence_wa) | raw_presence_wa == "?") ~ "S",
    raw_presence_fl == "?" ~ "?",
    is.na(raw_presence_fl) ~ "NA",
    TRUE ~ "M")) %>%
  mutate(Brussels = case_when(
    (is.na(raw_presence_fl) | raw_presence_fl == "?") & raw_presence_br == "X" & (is.na(raw_presence_wa) | raw_presence_wa == "?") ~ "S",
    raw_presence_br == "?" ~ "?",
    is.na(raw_presence_br) ~ "NA",
    TRUE ~ "M")) %>%
  mutate(Wallonia = case_when(
    (is.na(raw_presence_fl) | raw_presence_fl == "?") & (is.na(raw_presence_br) | raw_presence_br == "?") & raw_presence_wa == "X" ~ "S",
    raw_presence_wa == "?" ~ "?",
    is.na(raw_presence_wa) ~ "NA",
    TRUE ~ "M")) %>%
  mutate(Belgium = case_when(
    raw_presence_fl == "X" | raw_presence_br == "X" | raw_presence_wa == "X" ~ "S", # One is "X"
    raw_presence_fl == "?" | raw_presence_br == "?" | raw_presence_wa == "?" ~ "?" # One is "?"
  ))
```

## Post-processing

When all terms have been mapped, we remove `raw_colnames()` from `taxon`:

```{r}
taxon %<>% select(-one_of(raw_colnames))
```

Inspect `taxon`:

```{r}
head(taxon)
```

As indicated before, it is good practise to keep the order of the Darwin Core fields as specified on the GBIF Resources web page. The mapping process will be a mixture of mapping static fields, unaltered and altered fields.

Save `taxon` as a .csv file. For this, we need to define the path for the taxon core:

```{r}
dwc_taxon_file = "../data/processed/taxon.csv"
```

Write as a .csv:

```{r}
write.csv(taxon, file = dwc_taxon_file, na = "", row.names = FALSE, fileEncoding = "UTF-8")
```


# Exercise: 


