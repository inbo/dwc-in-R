[
["index.html", "Standardizing data to Darwin Core using R 1 Introduction", " Standardizing data to Darwin Core using R Damiano Oldoni, Lien Reyserhove, Stijn Van Hoey, Dimitri Brosens, Tanja Milotic, Peter Desmet 2018-02-23 1 Introduction This workshop material was developed for the 2018 Biodiversity Data Management at the Safeguarding Biodiversity Data for the Future conference. It covers: Good enough practices in data management Tidy data exercise Introduction to Darwin Core Introduction to dplyr Transforming data to Darwin Core with dplyr "],
["tidy-data-exercise.html", "2 Tidy data exercise", " 2 Tidy data exercise See the tidy data exercise presentation. "],
["creating-darwin-core-with-r.html", "3 Creating Darwin Core with R 3.1 Introduction 3.2 Setup 3.3 Import and clean data 3.4 Map to Darwin Core Archive", " 3 Creating Darwin Core with R 3.1 Introduction This tutorial describes how to map checklist data to Darwin Core in a stepwise manner. It is good practice to use this approach each time you map your data. Setup Load libraries Define locale Import and clean data Import data Inspect data Clean data Further processing Map to Darwin Core Archive Pre-processing Mapping General concept Static Darwin Core fields Unaltered Darwin Core fields Altered Darwin Core fields Post-processing We’ll walk through the tutorial step-by-step by using the Inventory of alien macroinvertebrates in Flanders, Belgium as an example. Afterwards, you can try it yourself by mapping the Checklist of non-native freshwater fishes in Flanders, Belgium. 3.2 Setup We load the libraries necessary to import, clean and map the data: library(tidyverse) # For data mapping library(magrittr) # For %&lt;&gt;% pipes library(readxl) # For reading excel files library(janitor) # For basic cleaning of the data Before we load the data, we define the locale: Sys.setlocale(&quot;LC_CTYPE&quot;, &quot;en_US.UTF-8&quot;) ## [1] &quot;en_US.UTF-8&quot; 3.3 Import and clean data 3.3.1 Import data Our raw datasat is an Excel file (AI_2016_Boets_etal_Supplement.xls). The import specifications for Excel files are more limited than those for delimited files (csv, tsv, txt). However, we think it’s useful to use Excel as a format in this exercise as this is often used to manage datasets. Go to Environment panel: Import dataset &gt; From Excel... For File/URL, click Browse and select AI_2016_Boets_etal_Supplement.xls Specify the Import Options: Name: raw_data Sheet: checklist NA: NA or leave empty First Row as Names: check Click on Data preview to verify if everything looks OK Click Import to generate the dataframe 3.3.2 Inspect data The simplest way for a quick overview of the raw data is by using the functions str() and head(): str(raw_data) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 73 obs. of 12 variables: ## $ Taxon ID : chr &quot;SAGAEFWEV&quot; &quot;SFGSTHSIM&quot; &quot;XIGXULXGI&quot; &quot;ZVJOBJJJX&quot; ... ## $ Phylum : chr &quot;Crustacea&quot; &quot;Crustacea&quot; &quot;Crustacea&quot; &quot;Crustacea&quot; ... ## $ Order : chr &quot;Sessilia&quot; &quot;Sessilia&quot; &quot;Sessilia&quot; &quot;Decapoda&quot; ... ## $ Family : chr &quot;Balanidae&quot; &quot;Balanidae&quot; &quot;Balanidae&quot; &quot;Astacidae&quot; ... ## $ Species : chr &quot;Amphibalanus amphitrite&quot; &quot;Amphibalanus improvisus&quot; &quot;Amphibalanus reticulatus&quot; &quot;Astacus leptodactylus&quot; ... ## $ Origin : chr &quot;South-Europe&quot; &quot;West-Atlantic&quot; &quot;Tropical and warm seas&quot; &quot;East-Europe&quot; ... ## $ First occurrence in Flanders: chr &quot;1952&quot; &quot;before 1700&quot; &quot;1997&quot; &quot;1986&quot; ... ## $ Pathway of introduction : chr &quot;shipping&quot; &quot;shipping&quot; &quot;shipping&quot; &quot;aquaculture&quot; ... ## $ Pathway mapping : chr &quot;Ship/boat hull fouling&quot; &quot;Ship/boat hull fouling | Ship/boat ballast water | Contaminant on animals (except parasites, species transporte&quot;| __truncated__ &quot;Ship/boat hull fouling&quot; &quot;Aquaculture | Pet/aquarium/terrarium species (including live food for such species )&quot; ... ## $ Salinity zone : chr &quot;M&quot; &quot;M&quot; &quot;M&quot; &quot;F&quot; ... ## $ Reference : chr &quot;Kerckhof and Catrijsse 2001&quot; &quot;Kerckhof and Catrijsse 2001&quot; &quot;Kerckhof and Catrijsse 2001&quot; &quot;Gerard 1986&quot; ... ## $ Pathway mapping remarks : chr NA &quot;considered transport with oyster lots as &#39;Contaminant on animals&#39;&quot; NA NA ... head(raw_data) # Displays the first 6 lines of the dataframe 3.3.3 Clean data We assume here that your dataset is tidy. If this is not the case, we refer to the Tidy data exercise. Unfortunately, starting with untidy data will make your script a lot more complex, with many preparatory steps before you can even start mapping! In a tidy dataset, you can start the mapping immediately. In some cases, some small cleaning steps could be made to clean raw_data. Here, the column names of raw_data contain capital letters: colnames(raw_data) ## [1] &quot;Taxon ID&quot; &quot;Phylum&quot; ## [3] &quot;Order&quot; &quot;Family&quot; ## [5] &quot;Species&quot; &quot;Origin&quot; ## [7] &quot;First occurrence in Flanders&quot; &quot;Pathway of introduction&quot; ## [9] &quot;Pathway mapping&quot; &quot;Salinity zone&quot; ## [11] &quot;Reference&quot; &quot;Pathway mapping remarks&quot; It’s easier to use lower case letters only and to discard all spaces in the column names. The package janitor provides some useful tools for this: raw_data %&lt;&gt;% clean_names() ## [1] &quot;taxon_id&quot; &quot;phylum&quot; ## [3] &quot;order&quot; &quot;family&quot; ## [5] &quot;species&quot; &quot;origin&quot; ## [7] &quot;first_occurrence_in_flanders&quot; &quot;pathway_of_introduction&quot; ## [9] &quot;pathway_mapping&quot; &quot;salinity_zone&quot; ## [11] &quot;reference&quot; &quot;pathway_mapping_remarks&quot; During the mapping, we will sequentially add new Darwin Core terms (see further). To avoid name clashes between the original columns in raw_data and the added Darwin Core columns, we add the prefix raw_ to the column names of raw_data: # Add prefix `raw_` to the column names of `raw_data`. colnames(raw_data) &lt;- paste0(&quot;raw_&quot;, colnames(raw_data)) ## [1] &quot;raw_taxon_id&quot; &quot;raw_phylum&quot; ## [3] &quot;raw_order&quot; &quot;raw_family&quot; ## [5] &quot;raw_species&quot; &quot;raw_origin&quot; ## [7] &quot;raw_first_occurrence_in_flanders&quot; &quot;raw_pathway_of_introduction&quot; ## [9] &quot;raw_pathway_mapping&quot; &quot;raw_salinity_zone&quot; ## [11] &quot;raw_reference&quot; &quot;raw_pathway_mapping_remarks&quot; We’re now all set to start mapping! 3.4 Map to Darwin Core Archive Even though raw_data contains all necessary information in a single data frame, a Darwin Core Archive might consist of multiple files, e.g. a core and extensions. We recommend to create the core file first and then the extensions. For each file, there are 3 steps: Pre-processing step: basic preparations before the mapping Mapping: sequential addition of the Darwin Core fields based on the raw values Post-processing step: removing the raw values and saving the file Schematic overview of the mapping process This is repeated for each core/extension file. Below, we’ll use the taxon core as an example. 3.4.1 Pre-processing We use a copy of raw_data as the starting point for the mapping of the taxon core. This is because raw_data is the starting point for the mapping of both the taxon core and the extensions. It needs to be untouched each time we start the mapping process. taxon &lt;- raw_data # Generate taxon by making a copy of raw_data Sometimes there are further pre-processing steps needed. E.g. in a vernacular name extension each name is a row, while in the original data the names could be columns or delimited values within a column. That kind of data requires separate() en gather() steps first. Here however, each record is taxon and no further pre-processing steps are required. 3.4.2 Mapping The mapping process is sequential: we add the Darwin Core terms to taxon step by step. The Darwin Core terms for each core/extension file can be found on the GBIF Resources page: It is good practice to inspect the Darwin Core terms on this webpage one by one to see whether a particular term can be used in your checklist. We respect the order of the terms as they listed on the GBIF resource page. We distinguish three types of Darwin Core terms mappings (static values, unaltered values and altered values) and for each one we will use mutate() and %&lt;&gt;% (double pipe). 3.4.3 Static values Static values are used for Darwin Core terms that need the same value for all records. Most often, they are absent in raw_data. This mostly concerns metadata fields in the taxon core file: taxon %&lt;&gt;% mutate(language = &quot;en&quot;) taxon %&lt;&gt;% mutate(license = &quot;http://creativecommons.org/publicdomain/zero/1.0/&quot;) taxon %&lt;&gt;% mutate(rightsHolder = &quot;Ghent University Aquatic Ecology&quot;) taxon %&lt;&gt;% mutate(datasetID = &quot;https://doi.org/10.15468/yxcq07&quot;) taxon %&lt;&gt;% mutate(datasetName = &quot;Inventory of alien macroinvertebrates in Flanders, Belgium&quot;) Other, non-metadata fields: taxon %&lt;&gt;% mutate(kingdom = &quot;Animalia&quot;) taxon %&lt;&gt;% mutate(nomenclaturalCode = &quot;ICZN&quot;) All these fields are added as extra columns to the data frame, in the same order as they were added: 3.4.4 Unaltered values Unaltered values are used for Darwin Core terms for which the content is an exact copy of the corresponding field in raw_data. This contrasts with altered fields, in which use a certain field in raw_data is the basis for further processing. Before deciding whether or not some basic processing is required, it is useful to screen the variables in raw_data for their specific content. distinct() is a useful function to show the unique values for a field: taxon %&gt;% distinct(raw_phylum) Note We use %&gt;% instead of %&lt;&gt;%, as we don’t want to add a new column to taxon. Some unaltered fields: taxon %&lt;&gt;% mutate(taxonID = raw_taxon_id) taxon %&lt;&gt;% mutate(scientificName = raw_species) taxon %&lt;&gt;% mutate(family = raw_family) View those 3 fields: 3.4.5 Altered values Altered values are used for Darwin Core terms for which the content in raw_data is used as a basis, but it needs to be standardized. This applies to Darwin Core terms for which we use a vocabulary or where we want to transform for clarity or to correct obvious mistakes. The main functions we use for these are: mutate() + recode() or mutate() + case_when(). 3.4.5.1 mutate() + recode() In this case, we aim to replace specific information in raw_data by new information specified in the code. For instance, raw_order will be mapped to the Darwin Core term order: taxon %&gt;% distinct(raw_order) Veneroida is a typo. We need to replace this by Venerida: taxon %&lt;&gt;% mutate(order = recode(raw_order, &quot;Veneroidea&quot; = &quot;Venerida&quot;)) We use select(), group_by_all() and summarize()to compare our newly mapped data with the original data. Note that the other values remain unaltered: taxon %&gt;% select(raw_order, order) %&gt;% group_by_all() %&gt;% summarize() Another use case: raw_phylum will be mapped to to Darwin Core term phylum. taxon %&gt;% distinct(raw_phylum) However, Crustacea is not a phylum but a subphylum. The phylum to which crustaceans belong is Arthropoda. We can correct this with recode(): taxon %&lt;&gt;% mutate (phylum = recode(raw_phylum, &quot;Crustacea&quot; = &quot;Arthropoda&quot;)) Other use cases (not applicable to our data): distribution %&lt;&gt;% mutate(description = recode(raw_d_n, &quot;Ext.?&quot; = &quot;Ext.&quot;, &quot;Ext./Cas.&quot; = &quot;Cas.&quot;, &quot;Cas.?&quot; = &quot;Cas.&quot;, &quot;Nat.?&quot; = &quot;Nat.&quot;, .missing = &quot;&quot;)) distribution %&lt;&gt;% mutate(locality = recode(value, &quot;AF&quot; = &quot;Africa (WGSRPD:2)&quot;, &quot;AM&quot; = &quot;pan-American&quot;, &quot;AS&quot; = &quot;Asia&quot;, &quot;AS-Te&quot; = &quot;temperate Asia (WGSRPD:3)&quot;, &quot;AS-Tr&quot; = &quot;tropical Asia (WGSRPD:4)&quot;, &quot;AUS&quot; = &quot;Australasia (WGSRPD:5)&quot;, &quot;Cult.&quot; = &quot;cultivated origin&quot;, &quot;E&quot; = &quot;Europe (WGSRPD:1)&quot;, &quot;Hybr.&quot; = &quot;hybrid origin&quot;, &quot;NAM&quot; = &quot;Northern America (WGSRPD:7)&quot;, &quot;SAM&quot; = &quot;Southern America (WGSRPD:8)&quot;, &quot;Trop.&quot; = &quot;Pantropical&quot;, .default = &quot;&quot;, .missing = &quot;&quot; )) 3.4.5.2 mutate() + case_when() case_when is often used together with mutate() when you want to make a new column (or change an existing one) based on the content of other existing variables. For instance, taxonRank information is lacking in raw_data. We need to generate this information based on the information contained in raw_species: Inspect raw_species: taxon %&gt;% distinct(raw_species) Although most raw_species are in fact species, Dreissena rostriformis bugensis is not a species but a subspecies. We need to make this distinction in the mapping process: taxon %&lt;&gt;% mutate(taxonRank = case_when( raw_species == &quot;Dreissena rostriformis bugensis&quot; ~ &quot;subspecies&quot;, raw_species != &quot;Dreissena rostriformis bugensis&quot; ~ &quot;species&quot;) ) We use select(), group_by_all() and summarize()to compare our newly mapped data with the original data: taxon %&gt;% select(raw_species, taxonRank) %&gt;% group_by_all() %&gt;% summarize() Other use cases (not applicable to our data): invasion_stage %&lt;&gt;% mutate(description = case_when( raw_status == &quot;A&quot; ~ &quot;casual&quot;, raw_status == &quot;A*&quot; ~ &quot;casual&quot;, raw_status == &quot;N&quot; ~ &quot;established&quot; )) distribution %&lt;&gt;% mutate(Flanders = case_when( raw_presence_fl == &quot;X&quot; &amp; (is.na(raw_presence_br) | raw_presence_br == &quot;?&quot;) &amp; (is.na(raw_presence_wa) | raw_presence_wa == &quot;?&quot;) ~ &quot;S&quot;, raw_presence_fl == &quot;?&quot; ~ &quot;?&quot;, is.na(raw_presence_fl) ~ &quot;NA&quot;, TRUE ~ &quot;M&quot;)) %&gt;% mutate(Brussels = case_when( (is.na(raw_presence_fl) | raw_presence_fl == &quot;?&quot;) &amp; raw_presence_br == &quot;X&quot; &amp; (is.na(raw_presence_wa) | raw_presence_wa == &quot;?&quot;) ~ &quot;S&quot;, raw_presence_br == &quot;?&quot; ~ &quot;?&quot;, is.na(raw_presence_br) ~ &quot;NA&quot;, TRUE ~ &quot;M&quot;)) %&gt;% mutate(Wallonia = case_when( (is.na(raw_presence_fl) | raw_presence_fl == &quot;?&quot;) &amp; (is.na(raw_presence_br) | raw_presence_br == &quot;?&quot;) &amp; raw_presence_wa == &quot;X&quot; ~ &quot;S&quot;, raw_presence_wa == &quot;?&quot; ~ &quot;?&quot;, is.na(raw_presence_wa) ~ &quot;NA&quot;, TRUE ~ &quot;M&quot;)) %&gt;% mutate(Belgium = case_when( raw_presence_fl == &quot;X&quot; | raw_presence_br == &quot;X&quot; | raw_presence_wa == &quot;X&quot; ~ &quot;S&quot;, # One is &quot;X&quot; raw_presence_fl == &quot;?&quot; | raw_presence_br == &quot;?&quot; | raw_presence_wa == &quot;?&quot; ~ &quot;?&quot; # One is &quot;?&quot; )) 3.4.6 Post-processing When all terms have been mapped, we remove the raw column names from taxon: taxon %&lt;&gt;% select(-starts_with(&quot;raw_&quot;)) Inspect taxon: head(taxon) As indicated before, it is good practise to keep the order of the Darwin Core fields as specified on the GBIF Resources web page. The mapping process will be a mixture of mapping static fields, unaltered and altered fields. Save taxon as a csv file. For this, we need to define the path to the taxon core file (relative to this script): dwc_taxon_file = &quot;../data/processed/taxon.csv&quot; Write as a csv: write.csv(taxon, file = dwc_taxon_file, na = &quot;&quot;, row.names = FALSE, fileEncoding = &quot;UTF-8&quot;) Note Make sure to set na = &quot;&quot; and row.names = FALSE when writing to a CSV file. "]
]
