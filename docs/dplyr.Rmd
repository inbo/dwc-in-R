---
title: "dplyr"
author:
- Damiano Oldoni
- Peter Desmet
- Stijn Van Hoey
- Lien Reyserhove
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    number_sections: true
    theme: yeti
    df_print: paged
knit: (function(input_file, encoding) { rmarkdown::render(input_file, encoding = encoding, output_file = paste0("../docs/",sub(".Rmd", ".html", basename(input_file))))})
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This tutorial will provide you the know-how for importing and analysing (tidy) data. We will use the same dataframe to test the most typical dplyr functionlalities. There is no better way to improve your programming skills than trying it yourself.

First of all, we need to load some libraries which are part of the tidyr package:

```{r read data}
library(readr)
```
```{r manipulate data}
library(dplyr)
library(magrittr)
```

## Read data
First of all, we need to import data in R. The most user friendly way to do it is by using the interface provided by RStudio. In the Environment window, click on *Import Dataset* and select *From Text (readr)...*. A window will pop-up and follow th next steps:
- click on *Browse* to selet the text file you want to import,
- select the right delimiter,
- check whether the classes of the columns fit your purpose and in case apply changes,
- change variable name in *code preview* if you prefer to save the data with a different name than filename,
- click on Import
A dataframe is automatically generated.

### Exercise
1. Read `survey_data_spreadsheet_tidy.csv`. Check whether the columns match the following types
  * `date`: `double`
  * `species`: `character`
  * `plot`: `integer`
  * `sex`: `character`
  * `weight_in_g`: `integer`
  * `device_remarks`: `character`
2. save the data into `data`

## Explore data
Before to start manipulate data, it is best practice exploring the imported dataframe in order to check whether everything is corectly imported and to have an idea about the data. R gives us several tools to do it:
- **view(df)** opens the entire dataframe in viewer
- **head(df)** returns the first part of a data frame. It works with several other data types (vectors, tables, ...). Specifiy how many rows to display with parameter `n`: `haed(df, n = )`, default `n = 6`
- **str(df)** displays the internal structure of the dataframe
- **col_names(df)** retrieves the column names
- **nrow(df)** returns the number of rows of the dataframe
- **ncol(df)** return the number of rows of the dataframe
- **mean(vector)** returns the (arithmetic) mean
- **max(vector)** returns the maximum
- **min(vector)** returns the minimum

You can apply `mean()`, `min()` and `max()` to dataframes as well: the functions will return respectively mean, minimum and maximum of esach column. However, in case one or more columns are not numeric, an error occurs. In case one or more `NA` are present in the data, you need to add `na.rm = TRUE` as parameter in the function call!

### Exercise
Test the functions introduced above to our dataframe `data`. In particular:
1. Display column names
```{r}
colnames(data)
```

2. How many columns are there?
```{r}
ncol(data)
```

3. How many rows are there?
```{r}
nrow(data)
```

4. Display the first 10 records
```{r}
head(data, n = 10)
```

5. Display data in viewer
```{r}
View(data)
```

6. Display structure of data
```{r}
str(data)
```

7. What is the mean weight?
```{r}
mean(data$weight_in_g, na.rm = TRUE)
```

8. What is the min weight?
```{r}
min(data$weight_in_g, na.rm = TRUE)
```


## Sort data
Sometimes is very useful to sort your data. The package `dplyr` offers the function `arrange()` to do it. If no columns are specified, the dataframe is sorted by values of the first column (`arrange(df)`). Use `desc()` to sort a variable in descending order.

### Exercise
1. Sort by date in ascending order
```{r sort data by date}
arrange(data)
data <- arrange(data)
```

2. Overwrite `data` with sorted output

```{r sort and overwrite}
arrange(data)
data <- arrange(data)
```

## Select columns and rows
You can select specific columns of dataframe by `select()`. In order to select rows: `filter()`. Only columns/rows where conditions are true are selected. For example, selecting a column:  `select(df, column_name)`. To select everything except a specific column use the minus symbol: `select(df, -column_name)`.

### Exercise
1. Display the column `weight_in_g`
```{r select}
select(data, weight_in_g)
```

2. Display only the records with `weight_in_g > 30`
```{r filter}
filter(data, weight_in_g > 30)
```

3. Select females with `weight_in_g > 30`
```{r filter two conditions}
filter(data, weight_in_g > 30, sex == "F")
```

4. Display only `weight_in_g` of females with `weight_in_g > 30`
```{r select }
females_weight_above_30_all <- filter(data, weight_in_g > 30, sex == "F")
select(females_weight_above_30_all, weight_in_g)
```

5. Save output of (4) as a variable: `females_weight_above_30`
```{r save output}
females_weight_above_30 <- select(females_weight_above_30_all, weight_in_g)
```

6. Select everything from `data` except device_remarks
```{r }
select(data, -device_remark)
```

## Pipes
As you probably noticed, we need to create new (temporary?) variables everytime we want to apply two or more functions. This method has several disadvantages, i.a. messy workspace, higher memory space usage, and higher chance of typos.

An alternative is to wrap (*nest*) functions one within each other, so that the output of a function would be considered the input of the other one. For example, if we have to apply `f1` to a dataframe `df` and `f2` to the output of `f1`, we write: 
```r
f2(f1(df, ...), ...)
```

This way of working with functions is typical of programming and is implemented in many other programming languages. The disadvantage of this approach is readibility: you have to read from right to left! Following our theoretical example, we apply  `f1` to `df` and then `f2`.

Can we avoid deciphering nested function calls, and making excessive use of temporary variables? Since 2014, the answer is yes, thanks to *pipe* operators. The most used one is the *forward pipe*: `%>%`. We can then rewrite the example above by using `%>%`:
```r
df %>% f1(...) %>% f2(...)
```
Easy, isn't?
As Stefan Milton, author of magrittr package, wrote in [this](https://www.r-statistics.com/2014/08/simpler-r-coding-with-pipes-the-present-and-future-of-the-magrittr-package/) blogpost:
> The order in which youâ€™d think of these steps is the same as the order in which they are written, and as the order in which they are executed.

If you want to create a variable based on the output of a series of functions:
```r
df2 <- df %>% f1(...) %>% f2(...)
```
If you want to overwrite the input dataframe, you can use the *compound assignment operator*, `%<>%` which is the composition of a forward `%>%`, and a backward `%<%` pipe:
```r
df %<>% f1(...) %>% f2(...)
```
The backward pipe works like the ypical asignment symbol `<-`

### Exercise
1. Display the column `weight_in_g` with values > 30 using pipes
```{r pipes1}
data %>% select(weight_in_g) %>% filter(weight_in_g > 30)
```

2. Select females with `weight_in_g > 30` using pipes
```{r pipes2}
data %>% filter(sex == "F", weight_in_g > 30)
```
3. Display only weight_in_g of females with weight in g > 30 
```{r pipes3}
data %>% filter(sex == "F", weight_in_g > 30) %>%
  select(weight_in_g)
```

4.  Save output of (3) as a variable: `females_weight_above_30`
```{r pipes4}
females_weight_above_30 <- data %>% filter(sex == "F", weight_in_g > 30) %>% select(weight_in_g)
```

## `distinct()`
The function `distinct()` retains only unique/distinct values of an input vector. If applied to dataframe, it retains only unique/distinct rows.

### Exercises
1. Show the unique sex values
```{r unique sex}
data %>% select(sex) %>% unique()
```

2. Show the unique species values
```{r unique species}
data %>% select(species) %>% unique()
```

